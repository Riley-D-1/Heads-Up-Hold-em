<!DOCTYPE html>
<html lang = "en">
<head>
    <meta name = "viewport" content="width=device-width, initial-scale=1.0">
    <title>Game</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<script src="https://cdn.jsdelivr.net/gh/krasimir/gifler/gifler.min.js"></script>
	<link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400..700&display=swap" rel="stylesheet">
    <link rel = "stylesheet" href = "style.css">
</head>
<body>
	<canvas id="game_window" width = "window.innerWidth" height = "window.innerHeight"></canvas>
	<div id="menu_buttons">
		<button id = "start_button" onclick="draw_rules_popup()">Start</button>
		<button id= "quit_button" onclick="quit_game()">Quit</button>
		<button id="understand_rules" onclick="game_loop()">I understand all the rules and am ready to play</button>
	</div>
	<div id = "bet_buttons">
		<button id="bet_button">Bet</button>
		<button id="fold_button">Fold</button>
	</div>
	<script>
		let you
		const canvas = document.getElementById("game_window")
		const ctx = canvas.getContext("2d")
		canvas.width = window.innerWidth
		canvas.height = window.innerHeight
		class player{
			constructor(name,money){
				this.name = name;
				this.money = money;
				this.status = "Loading";
			}
			get_money(){
				return this.money
			}
			get_name(){
				return this.name
			}
			flip_own_coins(){
				this.priv_coins = Coin_Flip(2)
			}
			get_status(){
				return this.status
			}
			update_status(status){
				this.status = status
			}
			pay(amount){
				this.money += amount
			}
			get_priv_coins(){
				return this.priv_coins
			}
		}
		class user extends player{
			constructor(name,money){
				super(name,money)
			}
			buyin_pay(buyin_cost){
				if (this.money > buyin_cost){
					this.money = this.money - buyin_cost
					this.status ="Paid Buyin"
					
				}
				else{
					//Player leave table
					alert("Start a new game to get your money back!")
					quit_game()
				}
			}
			gamble(player_list,curr_bet){
				bet_button.style.display = 'block';
				fold_button.style.display = 'block';
				bet_button.onclick = () => {
					handle_bet(curr_bet, player_list);
				};

				fold_button.onclick = () => {
					handle_fold(curr_bet, player_list);
				};
			}
			bet(amount){
				if (this.money > amount){
					this.money-=amount
					this.status =`Bet ${amount}`
				}else{
					alert("Start a new game to get your money back!")
					quit_game()
				}
			}
		}
		class bot extends player{
			constructor(name,money,difficulty){
				super(name,money)
				this.difficulty = difficulty
				this.status = "Loading";
			}
			gamble(curr_bet){
				let risk_lvl = Math.floor(this.difficulty*10)
				this.difficulty = Math.random()
				
				if (this.priv_coins === "hh" ||this.priv_coins === "tt"){
					if (this.money > curr_bet){
						this.money-=curr_bet
						this.status =`Bet ${curr_bet}`
					}
					else{
						fold(this.name)
						this.status ="Folded"
					}
				}else{
					if (risk_lvl < 3) {
						fold(this.name)
						this.status ="Folded"
					} else {
						if (this.money > curr_bet){
							this.money-=curr_bet
							this.status = `Bet ${curr_bet}`
						}else{
							fold(this.name)
							this.status = "Folded"
						}
					}
				}	
			}	
			
			buyin_pay(buyin_cost){
				if (this.money > buyin_cost){
					this.money = this.money - buyin_cost
					return `${this.name} paid`
					
				}
				else{
					//KILL Bot instance and leave table 
					clearInterval(); 
					this.status = "No Money"
					player_list = player_list.filter(p => p !== this);
					alert(`${this.name} ran out of money and left the table`)
				}
			}	
		}

        function Coin_Flip(count){
			// this is done :)
			let temp_flipped_coins = []
			for (let i= 0; i < count; i++){
				let rand_num = Math.random();
				if (rand_num <= 0.5){
					temp_flipped_coins.push("h")
				}
				else{
					temp_flipped_coins.push("t")
				}
			}
			return temp_flipped_coins
        }

		function handle_bet(current_bet,player_list) {
			you.bet(current_bet)
			fold_button.style.display = 'none';
			bet_button.style.display= 'none';
			const community_coins = Coin_Flip(4)
			anim_flip()
			setTimeout(() => {
				draw_game(player_list, "yes","yes",community_coins);
			}, 2100);
			let final_hands = []
			let players_in = []
			player_list.forEach(element => {
				if (element.get_status() === "Folded"){
					//do nothing 	
				}	
				else{
					let personal_coins = element.get_priv_coins()
					let combined = [...personal_coins, ...community_coins]
					final_hands.push(hand_check(combined))
					players_in.push(element)
					console.log(combined)
				}
				});
				console.log(players_in.length)
				if (players_in.length < 1){
					console.log("Tied Winners")
					let best_hand = final_hands[0]
					players_in.forEach((element,i) => {
						const priv = element.get_priv_coins();
						const combined = [...priv, ...community_coins];
						const hand_value = hand_check(combined);
					});
					tie_break(players_in,current_bet*player_list.length+6*4)
				}else if(players_in.length === 0){
					console.log("No Winner")
					win_screen("No",player_list)
				
				}else{
					console.log("Winner",players_in[0])
					win_screen(players_in[0],player_list)
					players_in[0].pay(current_bet*player_list.length+6*4)
					
				}
		}

		function handle_fold(current_bet,player_list) {
			you.update_status("Folded")
			fold_button.style.display = 'none';
			bet_button.style.display= 'none';
			const community_coins = Coin_Flip(4)
			anim_flip()
			setTimeout(() => {
				draw_game(player_list, "yes","yes",community_coins);
			}, 2100);
			let final_hands = []
			let players_in = []
			player_list.forEach(element => {
				if (element.get_status() === "Folded"){
					//do nothing 	
				}	
				else{
					let personal_coins = element.get_priv_coins()
					let combined = [...personal_coins, ...community_coins]
					final_hands.push(hand_check(combined))
					players_in.push(element)

				}
				});
				console.log(players_in.length)
				if (players_in.length < 1){
					console.log("Tied Winners")
					let best_hand = final_hands[0]
					players_in.forEach((element,i) => {
						const priv = element.get_priv_coins();
						const combined = [...priv, ...community_coins];
						const hand_value = hand_check(combined);
					});
					tie_break(players_in,current_bet*player_list.length+6*4)
				}else if(players_in.length === 0){
					console.log("No Winner")
					win_screen("No",player_list)
				
				}else{
					console.log("Winner",players_in[0])
					win_screen(players_in[0],player_list)
					players_in[0].pay(current_bet*player_list.length+6*4)
					
				}
			}
		function win_screen(vaule,player_list){
			setTimeout(() => {
				console.log('test')
				if (vaule !== "no"){
					ctx.clearRect(0, 0, canvas.width, canvas.height)
					ctx.fillStyle = '#497425'
					ctx.fillRect(0, 0, canvas.width, canvas.height)
					ctx.fillStyle = "#ffffff"
					ctx.font = "bold 48px Pixelify Sans";
					ctx.textAlign = "center";
					ctx.fillText(`${vaule.name} wins the pot!`, canvas.width / 2, canvas.height / 2);
					next_round(player_list)
				}else{
					ctx.clearRect(0, 0, canvas.width, canvas.height)
					ctx.fillStyle = '#497425'
					ctx.fillRect(0, 0, canvas.width, canvas.height)
					ctx.fillStyle = "#ffffff"
					ctx.font = "bold 48px Pixelify Sans";
					ctx.textAlign = "center";
					ctx.fillText(`Nobody wins`, canvas.width / 2, canvas.height / 2);
					next_round(player_list)
				}
			},4100);
		}
		function next_round(player_list){
			setTimeout(() => {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				fold_button.style.display = 'none';
				bet_button.style.display = 'none';

				// Reset player statuses and flip new coins
				player_list.forEach(player => {
					player.update_status("Waiting");
					player.flip_own_coins();
				});

				// Redraw game board with fresh private coins only
				draw_game(player_list, "yes", "no");

				// Animate coin flip and start betting after delay
				anim_flip();
				setTimeout(() => {
					draw_game(player_list, "yes", "no");
					gamble(player_list);
				}, 2100);
			},5100);
		}
		function name_gen(num_of_names){
			// This one is done too
			// got a big ass list of random names and put some  fun ones in 
			const names = [
			"Liam", "Emma", "Noah", "Olivia", "Ava", "Elijah", "Sophia", "Lucas", "Isabella", "Mason",
			"Mia", "Ethan", "Charlotte", "Logan", "Amelia", "James", "Harper", "Benjamin", "Evelyn", "Jacob",
			"Abigail", "Michael", "Ella", "Alexander", "Scarlett", "Henry", "Grace", "Jackson", "Chloe", "Sebastian",
			"Luna", "Aiden", "Layla", "Matthew", "Aria", "Samuel", "Zoey", "David", "Nora", "Joseph",
			"Levi", "Hazel", "Owen", "Lily", "Wyatt", "Ellie", "John", "Aurora", "Daniel",
			"Gabriel", "Penelope", "Carter", "Victoria", "Jayden", "Hannah", "Luke", "Stella", "Anthony",
			"Isaac", "Savannah", "Grayson", "Brooklyn", "Julian", "Bella", "Lincoln", "Claire", "Nathan", "Skylar",
			"Christian", "Lucy", "Hunter", "Anna", "Connor", "Violet", "Aaron", "Charles", "Alice",
			// Weird but cool names
			"Blade", "Shadow", "Nova", "Onyx", "Echo", "Genesis"
			];
			const shuffled = names.sort(() => 0.5 - Math.random());
			return shuffled.slice(0, num_of_names);
		}

		function start_game(bot_count,buyin_cost){
			//fix me
			
			if (localStorage.getItem('Money') === null){
				console.log("Money reset to default amount")
				localStorage.setItem("Money", 200);
				console.log(localStorage.getItem('Money'))
			}else if(localStorage.getItem('Money') < 6){
				alert("Hey, you ran out of money. Lucky its not real money! You're reset to 200 Money")
				localStorage.setItem("Money", 200)
			}
			else{
				console.log(localStorage.getItem('Money'))
			}
			
			bot_names = name_gen(bot_count)
			let player_list = []
			console.log(bot_count)
			for (let i = 0; i < bot_count; i++){
				let temp_bot = new bot(bot_names[i],200,Math.random())
				player_list.push(temp_bot)
			}
			let temp_user = new user("You",localStorage.getItem('Money'))
			you = temp_user
			player_list.push(temp_user)
			return player_list	
		}

		function quit_game(){
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			window.location.href = 'index.html';
		}

		function hand_check(hand){
			const heads_count = hand.filter(item => item === "h").length;
			const tails_count = hand.filter(item => item === "t").length;	
			if (heads_count === tails_count){
				return 3 //"Split"
			}else if (heads_count === 4|| tails_count ===4){
				return 4 //"Quad"
			} else if (heads_count === 5|| tails_count === 5){
				return 5 //"Five Frenzy"
			} else if (heads_count === 6||tails_count === 6 ){
				return 6 //"Flipstorm"
			}
			else{
				return "Error, not valid handtype just yet"
			}
		}

	function tie_break(tied_players, pot, community_coins) {
		let max_heads = -1;
		let final_winners = [];

		tied_players.forEach(player => {
			const priv = player.get_priv_coins()
			const combined = [...priv, ...community_coins]
			const heads_count = combined.filter(coin => coin === "h").length
			if (heads_count > max_heads) {
			max_heads = heads_count
			final_winners = [player]
			} else if (heads_count === max_heads) {
			final_winners.push(player)
			}
		});
		const split_pot = pot / final_winners.length;
		final_winners.forEach(player => {
			player.pay(split_pot)
			console.log(`Tie-break winner: ${player.get_name()} receives ${split_pot}`)
		});
		if (final_winners.length === 1) {
			win_screen(final_winners[0])
		} else {
			const names = final_winners.map(p => p.get_name()).join(", ")
			win_screen(`Tie-break winners: ${names}`)
		}
		}



		function gamble(players){
			const bet_amount = Math.floor(Math.random()*10)
			players.forEach(element => {
				if (element instanceof bot) {
					element.gamble(bet_amount);
				}else{
					you.gamble(players,bet_amount)
				}
			});
		}

		function fold(player){
			player.status = "Folded"
		}

		function draw_main_menu(){
			understand_rules.style.display = 'none';
			fold_button.style.display = 'none';
			bet_button.style.display= 'none';
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			const backgroundImage = new Image();
    		backgroundImage.src = 'assets/menu.png';
			backgroundImage.onload = function() {
				ctx.drawImage(backgroundImage,0, 0, canvas.width, canvas.height );
			};
		}

		function draw_rules_popup(){
			// Done i think
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			start_button.style.display = 'none';
			quit_button.style.display = 'none';
			understand_rules.style.display = 'block';
			ctx.fillStyle = '#497425'
			ctx.fillRect(0, 0, canvas.width, canvas.height); 
			ctx.font = '50px Pixelify Sans'
			ctx.fillStyle = '#f7ba47'
			ctx.textAlign = "center"
			ctx.fillText("Rules for Heads Up Hold'em", canvas.width / 2, 120);
			ctx.font = '20px Pixelify Sans'
			const rules = [
			"There are 4 different hand types, ordered from worst to best:",
			"1. Split (3 of each)",
			"2. Quad (4 of the same type)",
			"3. Five Frenzy (5 of the same type)",
			"4. Flip Storm (6 of the same type)",
			"Gameplay Rules",
			"- Player pays the buy-in fee (Costs 6 Money atm)",
			"- Each player flips their 2 private coins.",
			"- Dealer is randomly selected.",
			"- A betting round occurs (starting on the dealer). In a clockwise order players can  bet or fold. (Players must all match the bet or can fold)",
			"- The dealer flips 4 community coins.",
			"- Count your heads and tails and use your highest number.",
			"- All personal coins are revealed. The player with the best hand type wins. (If players tie on a hand, heads triumph over tails. If there is still a tie, the pot is split equally.)"
			];
			ctx.textAlign = "left"
			rules.forEach((rule, i) => {
				ctx.fillText(rule, 10, 180 + i * 30);
			});
			console.log("drawn instructions popup")
			console.log(200/Math.random()*Math.random())

		}

		function draw_game(player_list,priv_coins,community_coins_check,community_coins){
			// AI was used to help with postioning
			console.log("drawing")
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			start_button.style.display = 'none';
			quit_button.style.display = 'none';
			understand_rules.style.display = 'none';
			ctx.fillStyle = '#497425'
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			ctx.font = '20px Pixelify Sans'
			ctx.fillStyle = '#f7ba47'
			// Need to add coin counter below player name for  all bots and players
			// Add priv and communtiy coins using (assets.Heads/png) and having a square around only add when flipped
			// Need to add names for all bots and players
			// add actions underneath for all bots and players (won, lost, folded, bet etc)
			//
			ctx.font = '20px Pixelify Sans';
			ctx.fillStyle = '#f7ba47';
			ctx.textAlign = 'center';
			const positions = [
				{ x: canvas.width / 2, y: 40 },
				{ x: canvas.width - 80, y: canvas.height / 2 },
				{ x: 80, y: canvas.height / 2 },
				{ x: canvas.width / 2, y: canvas.height - 60 }
			];
			player_list.forEach((element,i) => {
				let pos = positions[i]
				ctx.font = '20px Pixelify Sans';
				ctx.fillStyle = '#f7ba47';
				ctx.textAlign = 'center';

				ctx.fillText(element.get_name(), pos.x, pos.y);
				ctx.fillText(`Money: ${element.get_money()}`, pos.x, pos.y + 20);
				ctx.fillText(element.get_status(), pos.x, pos.y + 40);
			});
			ctx.strokeStyle = '#ffffff'
			ctx.lineWidth = 2
			ctx.strokeRect((canvas.width - 700) / 2, (canvas.height-500) / 2, 700, 150)
			ctx.textAlign = 'center';
			ctx.fillStyle = '#ffffff'
			ctx.fillText("Community Coins",canvas.width/ 2,380)
			ctx.strokeRect((canvas.width - 400) / 2, 650, 400, 150)
			ctx.textAlign = 'center';
			ctx.fillStyle = '#ffffff'
			ctx.fillText("Priv Coins",canvas.width/ 2,625)
			if (priv_coins === "yes") {
				const coins = you.get_priv_coins();
				const coinSize = 128;
				const spacing = 128;
				const boxX = (canvas.width - 400) / 2;
				const boxY = 650;
				const boxWidth = 400;
				const boxHeight = 150;

				const x = boxX + (boxWidth - coins.length * spacing) / 2;
				const y = boxY + (boxHeight - coinSize) / 2;

				for (let i = 0; i < coins.length; i++) {
					const coin = coins[i];
					const img = new Image();
					img.src = coin === "h" ? 'assets/heads.png' : 'assets/tails.png';
					img.onload = () => {
						ctx.drawImage(img, x + i * spacing, y, coinSize, coinSize);
					};
				}
			}

			if (community_coins_check === "yes") {
			const coins = community_coins;
			const coinSize = 128;
			const spacing = 128;
			const boxX = (canvas.width - 700) / 2;
			const boxY = (canvas.height - 500) / 2;
			const boxWidth = 700;
			const boxHeight = 150;

			const x = boxX + (boxWidth - coins.length * spacing) / 2;
			const y = boxY + (boxHeight - coinSize) / 2;

			for (let i = 0; i < coins.length; i++) {
				const coin = coins[i];
				const img = new Image();
				img.src = coin === "h" ? "assets/heads.png" : "assets/tails.png";
				img.onload = () => {
				ctx.drawImage(img, x + i * spacing, y, coinSize, coinSize);
				};
			}
			}
		}

		function anim_flip() {
			// AI WROTE MOST OF THIS fucnction cause even ai took forever to get right
			const canvas = document.getElementById("game_window");
			const ctx = canvas.getContext("2d");

			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			ctx.imageSmoothingEnabled = false;

			const sprite = new Image();
			sprite.src = "assets/coin_sized.png";

			const frameWidth = 64;
			const frameHeight = 36;
			const framesPerRow = 3;
			const totalRows = 5;
			const totalFrames = framesPerRow * totalRows;
			const frameDuration = 2000 / totalFrames; // 2 seconds total

			let currentFrameIndex = 0;
			let animationInterval;

			function drawFrame(frameIndex) {
				const row = Math.floor(frameIndex / framesPerRow);
				const col = frameIndex % framesPerRow;

				const scale = canvas.width * 0.6 / frameWidth;
				const destWidth = frameWidth * scale;
				const destHeight = frameHeight * scale;
				const destX = (canvas.width - destWidth) / 2;
				const destY = (canvas.height - destHeight) / 2;

				ctx.fillStyle = "#497425";
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				ctx.drawImage(
					sprite,
					col * frameWidth, row * frameHeight,
					frameWidth, frameHeight,
					destX, destY,
					destWidth, destHeight
				);
			}

			function startAnimation() {
				animationInterval = setInterval(() => {
					drawFrame(currentFrameIndex);
					currentFrameIndex++;
					if (currentFrameIndex >= totalFrames) {
						clearInterval(animationInterval);
						console.log("done")
						return "done"
						
					}
				}, frameDuration);
			}

			sprite.onload = () => {
				startAnimation();
			};
		}

		function game_loop(){
			// game logic fix needed
			const audio = new Audio('music/Get_After_It.ogg')
			audio.play()
			let player_list = start_game(3,6)
			player_list.forEach(player => {
				player.buyin_pay(6)
			});
			draw_game(player_list,"no","no")
			you.flip_own_coins()
			player_list.forEach(element => {
				element.flip_own_coins()
			});
			anim_flip()
			setTimeout(() => {
				draw_game(player_list, "yes","no")
				gamble(player_list)
			}, 2100);
			
		}

		window.onload = function(){
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			draw_main_menu()
		}
    </script>
</body>
</html>